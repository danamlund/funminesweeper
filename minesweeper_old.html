<html>
    <head>
        <meta charset="utf-8" />
        <title>Minesweeper</title>
    </head>
    <body>

        <canvas id="canvas" width="500" height="500"></canvas>

        <h1 id="minesresult"></h1>

        <pre id="debugpre"></pre>

        <script>
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");

         function Minesweeper(args) {
             seed = args.seed || Math.floor(Math.random() * 2147483647);
             seed = seed % 2147483647;
             if (seed <= 0) {
                 seed += 2147483646;
             }
             function rand() {
                 return seed = seed * 16807 % 2147483647;
             }

             this.width = args.width || 16;
             this.height = args.height || 16;
             this.mines = args.mines || 40;
             this.seed = seed;
             this._mined = [];
             this._flagged = [];
             this._dug = [];
             this._blocked = [];

             this.clear = function() {
                 for (var x = 0; x < this.width; x++) {
                     this._mined[x] = [];
                     this._flagged[x] = [];
                     this._dug[x] = [];
                     this._blocked[x] = [];
                     for (var y = 0; y < this.height; y++) {
                         this._mined[x][y] = false;
                         this._flagged[x][y] = false;
                         this._dug[x][y] = false;
                         this._blocked[x][y] = false;
                     }
                 }
             }

             this.placeMines = function() {
                 var count = 10000;
                 for (var minesLeft = this.mines; minesLeft > 0;) {
                     var x = rand() % this.width;
                     var y = rand() % this.height;
                     if (!this._mined[x][y] && !this._blocked[x][y]) {
                         this._mined[x][y] = true;
                         minesLeft--;
                     }
                     if (count-- <= 0) {
                         this.mines -= minesLeft;
                         return;
                     }
                 }
             };

             this.dug = function(x, y) {
                 return this._dug[x][y];
             };

             this.flagged = function(x, y) {
                 return this._flagged[x][y];
             };

             this.mined = function(x, y) {
                 return this._mined[x][y];
             };
             this.blocked = function(x, y) {
                 return this._blocked[x][y];
             };
             this.free = function(x,y) {
                 return !this.dug(x, y) && !this.flagged(x, y) && !this.blocked(x, y);
             };

             this.neighbors = function(x, y) {
                 var out = [];
                 for (var dx = -1; dx <= 1; dx++) {
                     for (var dy = -1; dy <= 1; dy++) {
                         if (x+dx >= 0 && x+dx < this.width
                             && y+dy >= 0 && y+dy < this.height
                             && !(dx == 0 && dy == 0)
                             && !this.blocked(x+dx, y+dy)) {
                             out.push({x:x+dx, y:y+dy});
                         }
                     }
                 }
                 return out;
             }
             this.forAll = function(fun) {
                 for (var x = 0; x < this.width; x++) {
                     for (var y = 0; y < this.height; y++) {
                         if (!this.blocked(x, y)) {
                             fun(x, y);
                         }
                     }
                 }
             }
             this.all = function() {
                 var out = [];
                 this.forAll((x,y) => out.push({x:x, y:y}));
                 return out;
             };
             
             this.dig = function(x, y) {
                 if (!this.dug(x, y) && !this.flagged(x, y) && !this.blocked(x, y)) {
                     this._dug[x][y] = true;
                     
                     if (!this.mined(x, y) && this.number(x, y) == 0) {
                         for (var n of this.neighbors(x, y)) {
                             this.dig(n.x, n.y);
                         }
                     }
                 }
             };
             
             this.flag = function(x, y) {
                 if (!this.dug(x, y) && !this.blocked(x, y)) {
                     this._flagged[x][y] = !this._flagged[x][y];
                 }
             }
             this.lost = function() {
                 for (var p of this.all()) {
                     if (this.dug(p.x, p.y) && this.mined(p.x, p.y)) {
                         return true;
                     }
                 }
                 return false;
             }
             this.won = function() {
                 for (var p of this.all()) {
                     if (!this.dug(p.x, p.y) && !this.mined(p.x, p.y)) {
                         return false;
                     }
                 }
                 return !this.lost();
             }
             this.minesLeft = function() {
                 var flagged = 0;
                 this.forAll((x,y) => {
                     if (this.flagged(x, y)) {
                         flagged++;
                     }});
                 return this.mines - flagged;
             }
             this.info = function(x, y) {
                 var out = {};
                 out.neighbors = 0;
                 out.mined = 0;
                 out.dug = 0;
                 out.flagged = 0;
                 out.empty = 0;
                 for (var n of this.neighbors(x, y)) {
                     out.neighbors++;
                     if (this.mined(n.x, n.y)) {
                         out.mined++;
                     }
                     if (this.dug(n.x, n.y)) {
                         out.dug++;
                     }
                     else if (this.flagged(n.x, n.y)) {
                         out.flagged++;
                     }
                     else {
                         out.empty++;
                     }
                 }
                 return out;
             }
             this.number = function(x, y) {
                 return this.info(x, y).mined;
             }

             this.matrix = function() {
                 var matrix = [];
                 for (var x = 0; x < this.width; x++) {
                     matrix[x] = [];
                 }
                 out = {};
                 out.set = function(x, y) {
                     matrix[x][y] = true;
                 }
                 out.get = function(x, y) {
                     return matrix[x][y];
                 }
                 return out;
             }

             this.zeroNeighbors = function(x, y, marked) {
                 if (!marked) {
                     marked = this.matrix();
                 }
                 if (marked.get(x, y)) {
                     return 0;
                 }
                 marked.set(x, y);
                 if (!this.mined(x, y) && this.number(x, y) == 0) {
                     zeros = 1;
                     for (var n of this.neighbors(x, y)) {
                         zeros += this.zeroNeighbors(n.x, n.y, marked);
                     }
                     return zeros;
                 } else {
                     return 0;
                 }
             };

             this.highestZeroNeighbors = function() {
                 var highest = { x:-1, y:-1, zeros:0 };
                 this.forAll((x,y) => {
                     var zeros = this.zeroNeighbors(x, y);
                     if (zeros > highest.zeros) {
                         highest.x = x;
                         highest.y = y;
                         highest.zeros = zeros;
                     }
                 });
                 if (highest.x == -1) {
                     return null;
                 } else {
                     return highest;
                 }
             };

             this.start = function() {
                 highest = this.highestZeroNeighbors();
                 if (highest) {
                     this.dig(highest.x, highest.y);
                 }
             }
             
             this.clear();
             this.placeMines();
             this.start();
             
             return this;
         }

         function auto_mines1(mines) {
             var handled = mines.matrix();
             var out = [];
             mines.forAll((x,y) => {
                 if (mines.dug(x, y)) {
                     var info = mines.info(x, y);
                     if (info.flagged == info.mined) {
                         for (var n of mines.neighbors(x, y)) {
                             if (!handled.get(n.x, n.y)
                                 && !mines.flagged(n.x, n.y)
                                 && !mines.dug(n.x, n.y)) {
                                 out.push({ type:"dig", x:n.x, y:n.y });
                                 handled.set(n.x, n.y);
                             }
                         }
                     }
                     if (info.neighbors - info.dug == info.mined) {
                         for (var n of mines.neighbors(x, y)) {
                             if (!handled.get(n.x, n.y)
                                 && !mines.flagged(n.x, n.y)
                                 && !mines.dug(n.x, n.y)) {
                                 out.push({ type:"flag", x:n.x, y:n.y });
                                 handled.set(n.x, n.y);
                             }
                         }
                     }
                 }
             });
             return out;
         }
         function auto_mines2(mines) {
             var flagged = 0;
             var out = [];
             mines.forAll((x,y) => {
                 if (mines.dug(x, y)) {
                     // empty
                 }
                 else if (mines.flagged(x, y)) {
                     flagged++;
                 } else {
                     out.push({ type:"dig", x:x, y:y });
                 }
             });

             if (flagged == mines.mines) {
                 return out;
             } else {
                 return [];
             }
         }
         function auto_mines3(mines) {
             var out = [];

             function check(x, y) {
                 maybe_mined = mines.matrix();
                 maybes = 0;
                 for (var n of mines.neighbors(x, y)) {
                     if (!mines.dug(n.x, n.y) && !mines.flagged(n.x, n.y)) {
                         maybe_mined.set(n.x, n.y);
                         maybes++;
                     }
                 }
                 for (var n of mines.neighbors(x, y)) {
                     if (mines.dug(n.x, n.y)) {
                         var info = mines.info(n.x, n.y);
                         var frees = [];
                         var seen_maybes = 0;
                         for (var m of mines.neighbors(n.x, n.y)) {
                             if (mines.dug(m.x, m.y)) {
                                 // empty
                             } else if (mines.flagged(m.x, m.y)) {
                                 // empty
                             } else if (maybe_mined.get(m.x, m.y)) {
                                 seen_maybes++;
                             } else {
                                 frees.push(m);
                             }
                         }
                         if (seen_maybes == maybes && info.mined - info.flagged == 1) {
                             for (var free of frees) {
                                 out.push({ type:"dig", x:free.x, y:free.y });
                             }
                         }
                     }
                 }
             }

             mines.forAll((x,y) => {
                 if (mines.dug(x, y)) {
                     var info = mines.info(x, y);
                     if (info.neighbors - info.dug - info.flagged >= 2
                         && info.mined - info.flagged == 1) {
                         check(x, y);
                     }
                 }
             });
             return out;
         }

         function myIndexOf(array, e) {
             var eString = JSON.stringify(e);
             for (var i = 0; i < array.length; i++) {
                 if (JSON.stringify(array[i]) == eString) {
                     return i;
                 }
             }
             return -1;
         }
         function myContains(array, e) {
             return myIndexOf(array, e) != -1;
         }
         function myPushIfNew(array, e) {
             if (!myContains(array, e)) {
                 array.push(e);
             }
         }
         function myDistinct(array) {
             var out = [];
             for (var e of array) {
                 myPushIfNew(out, e);
             }
             return out;
         }
         
         function MinesPermutations(mines) {
             this.added = [];
             this.poss = [];
             this.constraints = [];

             this.add = function(x, y) {
                 if (myContains(this.added, {x:x, y:y})) {
                     return;
                 }
                 if (!mines.dug(x, y)) {
                     error("Cannot .add non-dug square");
                 }
                 this.added.push({x:x, y:y});
                 var info = mines.info(x, y);
                 var indices = [];
                 for (var n of mines.neighbors(x, y)) {
                     if (!mines.dug(n.x, n.y) && !mines.flagged(n.x, n.y)) {
                         if (!myContains(this.poss, n)) {
                             this.poss.push(n);
                         }
                         var index = myIndexOf(this.poss, n);
                         indices.push(index);
                     }
                 }
                 this.constraints.push({ indices: indices,
                                         matches: (info.mined - info.flagged)});
             };
             this.addEmpty = function(x, y) {
                 if (!mines.free(x, y)) {
                     error("Cannot .addEmpty non-free square");
                 }
                 for (var n of mines.neighbors(x, y)) {
                     if (mines.dug(n.x, n.y)) {
                         this.add(n.x, n.y);
                     }
                 }
                 if (!myContains(this.poss, {x:x, y:y})) {
                     this.poss.push({x:x, y:y});
                 }
             };
             this.addNeighbors = function() {
                 for (var a of this.added) {
                     for (var n of mines.neighbors(a.x, a.y)) {
                         if (mines.dug(n.x, n.y) && mines.info(n.x, n.y).empty >= 1) {
                             this.add(n.x, n.y);
                         }
                     }
                 }
             }
             this.addNeighborsLimit = function(positionsToAdd) {
                 var maxAdded = this.added.length + positionsToAdd;
                 var addedSomething = true;
                 while (addedSomething && this.added.length < maxAdded) {
                     addedSomething = false;
                     for (var a of this.added) {
                         for (var n of mines.neighbors(a.x, a.y)) {
                             if (mines.dug(n.x, n.y)
                                 && mines.info(n.x, n.y).empty >= 1
                                 && !myContains(this.added, n)) {
                                 this.add(n.x, n.y);
                                 if (this.added.length >= maxAdded) {
                                     return;
                                 }
                             }
                         }
                     }
                 }
             }
             this.size = function() {
                 return this.poss.length;
             }
             // Group indices that are connected through a constraint.
             // Separating indices into more than one group is a performance optimization.
             this.separate_poss = function() {
                 var ungroupedIndices = [];
                 for (var i = 0; i < this.poss.length; i++) {
                     ungroupedIndices.push(i);
                 }
                 var out = [];
                 while (ungroupedIndices.length > 0) {
                     var group = [];
                     group.push(ungroupedIndices.shift());
                     for (var i = 0; i < this.constraints.length; i++) {
                         var constraint = this.constraints[i];
                         var ingroup = false;
                         for (var index of constraint.indices) {
                             if (group.includes(index)) {
                                 ingroup = true;
                             }
                         }
                         if (ingroup) {
                             for (var index of constraint.indices) {
                                 if (!group.includes(index)) {
                                     group.push(index);
                                     ungroupedIndices.splice(ungroupedIndices.indexOf(index), 1);
                                     i = 0; // run through constraints again
                                 }
                             }
                         }
                     }
                     out.push(group);
                 }
                 return out;
             };
             this.split = function(group_indices) {
                 var out = [];
                 for (var group of group_indices) {
                     var mp = new MinesPermutations(mines);
                     for (var index of group) {
                         for (var n of mines.neighbors(this.poss[index].x, this.poss[index].y)) {
                             if (mines.dug(n.x, n.y)) {
                                 mp.add(n.x, n.y);
                             }
                         }
                     }
                     out.push(mp);
                 }
                 return out;
             }
             this.groups = function(maxGroupSize) {
                 if (maxGroupSize === undefined) {
                     return this.split(this.separate_poss());
                 }
                 var group_indices = [];
                 for (var gs of this.separate_poss()) {
                     if (maxGroupSize && gs.length > maxGroupSize) {
                         var group_size = gs.length / Math.ceil(gs.length / maxGroupSize);
                         for (var s = 0; s < gs.length; s += group_size) {
                             group_indices.push(gs.slice(s, Math.min(s + group_size, gs.length)));
                         }
                     } else {
                         group_indices.push(gs);
                     }
                 }
                 return this.split(group_indices);
             };

             this.groupsToMoves = function(maxGroupSize, considerMinesLeft) {
                 var max_mines = considerMinesLeft ? mines.minesLeft() : undefined;
                 var grouped_permutations = this.groups(maxGroupSize);
                 var out = [];
                 for (var permutations of grouped_permutations) {
                     var moves = permutations.permutateToMoves(max_mines);
                     if (moves === false) {
                         return false;
                     }
                     out = out.concat(moves);
                 }
                 return out;
             };

             this.valid = function(permutation, max_mines) {
                 if (max_mines) {
                     var perm_mines = 0
                     for (var perm of permutation) {
                         perm_mines += perm;
                     }
                     if (perm_mines > max_mines) {
                         return false;
                     }
                 }
                 for (var constraint of this.constraints) {
                     var sum = 0;
                     for (var index of constraint.indices) {
                         sum += permutation[index];
                     }
                     if (sum != constraint.matches) {
                         return false;
                     }
                 }
                 return true;
             };
             this.next = function(permutation) {
                 for (var i = 0; i < permutation.length; i++) {
                     if (permutation[i]) {
                         permutation[i] = false;
                     } else {
                         permutation[i] = true;
                         return true;
                     }
                 }
                 return false;
             }
             this.permutate = function(max_mines) {
                 var index_mine = [];
                 var index_not_mine = [];
                 var out = { is_mines: [],
                             is_not_mines: [],
                             min_mines: mines.mines,
                             max_mines: 0 };
                 var permutation = [];
                 for (var index = 0; index < this.poss.length; index++) {
                     permutation.push(false);
                     index_mine[index] = 0;
                     index_not_mine[index] = 0;
                 }
                 do {
                     if (this.valid(permutation, max_mines)) {
                         var permutation_mines = 0;
                         for (var index = 0; index < this.poss.length; index++) {
                             if (permutation[index]) {
                                 permutation_mines++;
                                 index_mine[index]++;
                             } else {
                                 index_not_mine[index]++;
                             }
                         }
                         if (permutation_mines < out.min_mines) {
                             out.min_mines = permutation_mines;
                         }
                         if (permutation_mines > out.max_mines) {
                             out.max_mines = permutation_mines;
                         }
                     }
                 }
                 while (this.next(permutation));

                 var mineProbability = {};
                 for (var index = 0; index < this.poss.length; index++) {
                     if (index_mine[index] >= 1 && index_not_mine[index] == 0) {
                         out.is_mines.push(this.poss[index]);
                     }
                     if (index_mine[index] == 0 && index_not_mine[index] >= 1) {
                         out.is_not_mines.push(this.poss[index]);
                     }
                     mineProbability[""+this.poss[index].x+","+this.poss[index].y] =
                         index_mine[index] / (index_mine[index] + index_not_mine[index]);
                 }
                 out.mineProbability = mineProbability;
                 return out;
             };
             this.tooManyPermutations = function() {
                 return this.size() > 24;
             };
             this.permutateToMoves = function(max_mines) {
                 if (this.tooManyPermutations()) {
                     debug("too many permutations (" + this.size() + ")");
                     return false;
                 } else {
                     var out = [];
                     var permutationsResult = this.permutate(max_mines);
                     for (var is_mine of permutationsResult.is_mines) {
                         out.push({type:"flag", x:is_mine.x, y:is_mine.y});
                     }
                     for (var is_not_mine of permutationsResult.is_not_mines) {
                         out.push({type:"dig", x:is_not_mine.x, y:is_not_mine.y});
                     }
                     return myDistinct(out);
                 }
             };
         };

         // Try all subsets permutations of dug tiles with neighboring empty tiles.
         function autoPermutationsSubset(mines, subsetSize) {
             var poss = [];
             mines.forAll((x,y) => {
                 var info = mines.info(x, y);
                 if (mines.dug(x, y)) {
                     if (info.empty >= 1) {
                         poss.push({x:x, y:y});
                     }
                 }
             });

             function rec(poss, left, current) {
                 if (!current) {
                     current = [];
                 }
                 if (left == 0) {
                     return [current];
                 }
                 var out = [];
                 for (var pos of poss) {
                     if (!myContains(current, pos)) {
                         out = out.concat(rec(poss, left - 1, current.concat([pos])));
                     }
                 }
                 return out;
             }

             var out = [];
             for (var permutationPoss of rec(poss, subsetSize)) {
                 var permutations = new MinesPermutations(mines);
                 for (var pos of permutationPoss) {
                     permutations.add(pos.x, pos.y);
                 }
                 var moves = permutations.permutateToMoves();
                 if (moves === false) {
                     return false;
                 }
                 out = out.concat(moves);
             }
             return myDistinct(out);
         }

         function auto_mines_remaining(mines) {
             var permutations = new MinesPermutations(mines);
             mines.forAll((x,y) => {
                 if (mines.free(x, y)) {
                     permutations.addEmpty(x, y);
                 }
             });
             return permutations.groupsToMoves(undefined, true);
         }
         
         function autoFullPermutation(mines) {
             var permutations = new MinesPermutations(mines);
             mines.forAll((x,y) => {
                 var info = mines.info(x, y);
                 if (mines.dug(x, y)) {
                     if (info.empty >= 1) {
                         permutations.add(x, y);
                     }
                 }
             });
             return permutations.groupsToMoves();
         }

         function auto_mines4(mines, maxGroupSize) {
             maxGroupSize = maxGroupSize || 24;
             var permutations = new MinesPermutations(mines);
             mines.forAll((x,y) => {
                 var info = mines.info(x, y);
                 if (mines.dug(x, y)) {
                     if (info.empty >= 1) {
                         permutations.add(x, y);
                     }
                 }
             });

             var grouped_permutations = permutations.groups(maxGroupSize);
             var out = [];
             for (var permutations of grouped_permutations) {
                 debug("## size="+ permutations.size());
                 vardump(permutations.permutate());
                 var moves = permutations.permutateToMoves();
                 if (moves === false) {
                     return false;
                 }
                 out = out.concat(moves);
             }
             return out;

         }

         function debug(msg) {
             document.getElementById("debugpre").innerHTML += msg+"\n";
         }
         function vardump(o) {
             debug(JSON.stringify(o));
         }
         
         function draw(canvas, mines, posx, posy) {
             var ctx = canvas.getContext("2d");
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             var size = Math.floor(Math.min(canvas.width / mines.width, canvas.height / mines.height));
             var margin = 1;;
             var size_wo_margin = size - 2*margin;

             for (var i = 50; i > 8; i--) {
                 ctx.font = i+"px sans-serif";
                 if (ctx.measureText("M").width < size_wo_margin*0.70) {
                     break;
                 }
             }

             ctx.fillStyle = "#000000";
             ctx.fillRect(posx * size - margin, posy * size - margin,
                          size + 2*margin, size + 2*margin);

             mines.forAll((x,y) => {
                 ctx.fillStyle = "#cccccc";
                 ctx.fillRect(x * size + margin, y * size + margin, size_wo_margin, size_wo_margin);

                 var char = false;
                 if (mines.flagged(x, y)) {
                     char = "🚩";
                 }
                 if (mines.dug(x, y)) {
                     if (mines.mined(x, y)) {
                         char = "💣";
                     } else {
                         char = ""+mines.number(x, y);
                     }
                 }
                 if (char) {
                     ctx.fillStyle = "#000000";
                     ctx.textAlign = "center";
                     ctx.textBaseline = "middle";
                     ctx.fillText(char, x * size + margin + size_wo_margin/2,
                                  y * size + margin + size_wo_margin/2 + size_wo_margin * 0.1);
                 }
             });
         }

         function move(mines, moves) {
             if (moves.length >= 1) {
                 for (var move of moves) {
                     if (move.type == "dig") {
                         mines.dig(move.x, move.y);
                     } else if (move.type == "flag") {
                         mines.flag(move.x, move.y);
                     }
                 }
                 return true;
             }
             return false;
         }

         function solve(mines) {
             var stats = {
                 subset1: 0,
                 subset2: 0,
                 mines_remaining: 0,
                 full_permutation: 0,
                 solveable: "maybe"};
             while (!mines.won() && !mines.lost()) {
                 var moves = autoPermutationsSubset(mines, 1);
                 if (moves === false) {
                     return stats;
                 }
                 if (move(mines, moves)) {
                     stats.subset1++;
                     continue;
                 }
                 var moves = autoPermutationsSubset(mines, 2);
                 if (moves === false) {
                     return stats;
                 }
                 if (move(mines, moves)) {
                     stats.subset2++;
                     continue;
                 }
                 
                 var moves = autoFullPermutation(mines);
                 if (move === false) {
                     return stats;
                 }
                 if (move(mines, moves)) {
                     stats.full_permutation++;
                     continue;
                 }
                 
                 var moves = auto_mines_remaining(mines);
                 if (moves === false) {
                     return stats;
                 }
                 if (move(mines, moves)) {
                     stats.mines_remaining++;
                     continue;
                 }

                 stats.solveable = false;
                 return stats;
             }

             stats.solveable = true;
             return stats;
         }

         function findSolveableMaybe() {
             for (var i = 0; i < 50; i++) {
                 var mines = new Minesweeper({seed: undefined});
                 if (solve(mines).solveable == "maybe") {
                     return new Minesweeper({seed: mines.seed});
                 }
             }
             debug("found no maybe solveable");
             return false;
         }

         /* var mines = findSolveableMaybe(); */
         /* var mines = new Minesweeper({seed: 1739384639}); */
         /* var mines = new Minesweeper({seed: 930533121}); */
         var mines = new Minesweeper({seed: 1280317977});
         
         /* var mines = new Minesweeper({seed: undefined}); */
         if (false) {
             mines = new Minesweeper({width: 5, height:5, mines:4});
             mines.clear();
             /* mines._mined[0][2] = true;
              * mines._mined[3][2] = true; */
             mines._mined[1][2] = true;
             mines._mined[4][2] = true;
             mines._mined[1][4] = true;
             mines._mined[3][4] = true;
             mines.start();
         }

         vardump(solve(mines));
         debug("flagged="+(mines.mines - mines.minesLeft())+"/"+mines.mines);

         
         var x = 0;
         var y = mines.height - 1;
         function checkWin() {
             if (mines.won()) {
                 document.getElementById("minesresult").innerHTML = "WINNER";
             }
             if (mines.lost()) {
                 document.getElementById("minesresult").innerHTML = "LOSER";
             }
         }
         function keyDownHandler(e) {
             /* if (!mines.won() && !mines.lost()) { */
             if (e.key == "ArrowLeft") {
                 if (x > 0) {
                     x--;
                 }
             } else if (e.key == "ArrowRight") {
                 if (x < mines.width - 1) {
                     x++;
                 }
             } else if (e.key == "ArrowUp") {
                 if (y > 0) {
                     y--;
                 }
             } else if (e.key == "ArrowDown") {
                 if (y < mines.height - 1) {
                     y++;
                 }
             } else if (e.key == "d") {
                 mines.dig(x, y);
             } else if (e.key == "f") {
                 mines.flag(x, y);
             } else if (e.key == "1") {
                 move(mines, auto_mines1(mines));
             } else if (e.key == "2") {
                 move(mines, auto_mines2(mines));
             } else if (e.key == "3") {
                 move(mines, auto_mines3(mines));
             } else if (e.key == "4") {
                 move(mines, auto_mines4(mines));
             } else if (e.key == "5") {
                 move(mines, autoPermutationsSubset(mines));
             } else if (e.key == "6") {
                 move(mines, autoPermutationsSubset(mines, 1));
             } else if (e.key == "7") {
                 move(mines, autoPermutationsSubset(mines, 2));
             } else if (e.key == "8") {
                 move(mines, autoPermutationsSubset(mines, 3));
             } else if (e.key == "9") {
                 move(mines, autoPermutationsSubset(mines, 4));
             } else if (e.key == "0") {
                 move(mines, autoPermutationsSubset(mines, 5));
             } else if (e.key == "-") {
                 move(mines, auto_mines_remaining(mines));
             }

             if (e.key == "i") {
                 debug("flagged="+(mines.mines - mines.minesLeft())+"/"+mines.mines);
             }
             if (e.key == "q") {
                 document.getElementById("debugpre").innerHTML = "";
             }
             checkWin();
             draw(canvas, mines, x, y);
             /* } */
         }
         document.addEventListener("keydown", keyDownHandler, false);
         draw(canvas, mines, x, y);
         debug("seed="+mines.seed);
         checkWin();
        </script>

    </body>
</html>
